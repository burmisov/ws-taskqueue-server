Websocket Server Communication
==============================

Задание: [посмотреть](https://docs.google.com/document/d/1O8dZVAnryDffUEJTMAayPiVsfS42EMagVtJburHYz2Q)

## Установка и запуск
В системе должен быть Redis с дефолтными настройками!

```sh
git clone https://github.com/burmisov/ws-taskqueue-server
npm install
npm start
```
Сервер слушает порт `8080` или указанный в `$PORT`

Если установить `$DEBUG = "wstq:*"`, можно увидеть расширенную отладочную выдачу
в консоли.

## Панель мониторинга
По адресу http://<сервер>:<порт> также доступна простая панель мониторинга.

## Формат объекта задачи

```js
{
  Id: 'c07951ca',
  ClientId: '7ff1781e',
  // ... прочие сведения о задаче
  Result: { /* Появляется после выполнения - то, что передал клиент */ }
}
```

## Протокол обмена сообщениями
Сообщения пересылаются поверх WebSockets в формате JSON.

Клиент => Сервер

```js
// Сведения об ID клиента:
{
  "type": "handshake",
  "clientId": "7ff1781e"
}

// Подтверждение выполнения задания
{
  "type": "ack",
  "taskId": "c07951ca",
  "payload": {
    // Необязательно - сведения о результате выполнения
  }
}

// Сообщение о занятости
{
  "type": "busy"
}
```

Сервер => Клиент

```js
// Выдача задания
{
  "type": "task",
  "payload": {
    "Id": "c07951ca",
    "ClientId": "7ff1781e",
    // ... прочие сведения о задании
  }
}
```

## Схема данных в redis
- `tasks-new:<ClientId>` - LIST задач для клиента с "ClientId"
- `tasks-pending` - HASH всех задач в обработке (ключ - ClientId)
- `tasks-finished` - LIST завершенных задач

## Особенности работы:
### Прямолинейный процесс
1. Новые задачи поступают в LIST'ы 'tasks-new:<clientId>'
2. Сервер следит за появлением задач в списках для подключенных клиентов
3. При наличии задачи для клиента она вынимается из списка, перекладывается
   в tasks-pending и передаётся на исполнение клиенту.
4. При получении от клиента подтверждения выполнения задачи она вынимается из
   tasks-pending, обогащается результатом и перекладывается в tasks-finished

### Обработка переподсоединения
1. Предположим клиенту была передана задача. Он не подтвердил её выполнение,
   после чего связь была нарушена.
2. При повторном соединении клиенту снова передаётся эта задача. Возможно,
   клиент уже занят этой (или другой) задачей, тогда он пришлёт сообщение,
   что занят. Сервер предполагает, что клиент занят именно той задачей, которая
   "висит" на клиенте по данным сервера и действует соответственно.
3. Возможно, после разрыва связи клиент уже завершил выполнение задачи. Тогда
   в текущей реализации он имеет шанс получить её повторно.

P.S. п.3 можно было бы частично исправить, доработав протокол соединения.
Например, при передаче Id клиент тут же передаёт сведения о том, что он
завершил некую задачу.

## TODO
1. Распилить handleConnection на блоки: обработка соединения -> вычисление типа
   ответа -> модификация состояния -> цикл. Можно сделать матрицу конфигурации
   состояние x сообщение -> ответ или ещё что-нибудь такое.
2. Добавить тесты.
3. Более детальные настройки redis, префиксов, интервалов проверки и пр.
4. Журнал.
5. Можно заливать задачи в один LIST; тогда нужно добавить его обработчик,
   который будет раскладывать появляющиеся в нём задачи по клиентским LIST'ам
6. Можно слушать изменения LIST'ов через Redis Keyspace Notifications. Потребует
   особой настройки Redis, и мало что даёт в большинстве случаев. На скорости
   выполнения относительно длинных очередей задач это не скажется.
7. Уточнить протокол и порядок работы клиента и сделать более адекватные
   реакции в пограничных ситуациях.
